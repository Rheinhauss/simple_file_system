# 操作系统  实验 4





> **王雨轩		1120190887		08011901**

[toc]

## **O. 使用说明**

双击可执行文件 `.exe` 运行。运行时有两种状态：一种是未加载镜像的状态，可以进行加载新建文件系统镜像的操作(new, sfs)；另一种是已加载镜像状态，可以进行文件系统内操作(包含exit) 。

随可执行文件附带一个预先准备好的镜像文件 `fs1.mfsimg` ，放置于同一路径下后打开可执行文件，输入命令 `sfs fs1.mfsimg ` 加载该镜像，随后即可随意使用。

具体操作说明请见下文。



### 提供操作与命令格式

类似 *nix 系统惯例，以下命令，除 `exit` 成功时返回保存文件名、 `open` 成功时返回 `fd` 值、 `ls` 成功时返回当前目录下所有文件信息，在成功执行后没有文字反馈，在出错时会提示具体错误。注意，同一路径下文件夹与文件不能重名。

- `new  <filesys_name>`
  - 建立一个新的简单文件系统，需提供名称；
- `sfs  <filesys_name>`
  - 打开一个简单文件系统，需提供名称；
- `exit`
  - 保存并退出打开的简单文件系统，名称不含扩展名( `.mfsimg` ) 时自动添加；
- `mkdir  <dir_name>`
  - 创建子目录，名称不能和当前目录下其它文件重复；
- `rmdir  <dir_name>`
  - 删除子目录，名称必须是当前目录下的 ***非空*** 文件夹，而非文件；
- `ls`
  - 显示当前目录内含的文件；
- `cd  <dir_name>`
  - 更改当前目录，目前只测试过相对路径进入下一级( `cd dir` )和上一级( `cd ..` )和绝对路径进入根目录( `cd /` )；
- `create  <file_name>`
  - 创建文件，名称不能和当前目录下其它文件重复；
- `open  <file_name>`
  - 打开文件，名称必须是当前目录下的文件，返回 `fd` 号；
- `close  <fd:int>`
  - 关闭文件，参数为 `0-127` 的整数，若提供的 `fd` 不对应已打开文件则报错；
- `read  <fd:int>`
  - 读文件，参数为 `0-127` 的整数，若提供的 `fd` 不对应已打开文件则报错；
- `write  <fd:int>`
  - 覆盖写入文件，参数为 `0-127` 的整数，若提供的 `fd` 不对应已打开文件则报错，如果对应，则进入输入状态，用 EOF 结束（手动输入 EOF 的方法为：Windows下按回车再按 Ctrl+Z 再按回车，*nix 下按Crtl+D）；
- `delete  <file_name>`
  - 删除文件，名称必须是当前目录下的文件而非文件夹。



## **I. 数据结构及符号说明**



### **数据结构**



#### FCBp

`FCBp` 是一个类似FCB的结构体，但是并不实际存储FCB的内容。它的

- 数据成员包括
  1. 此FCB所在块的起始地址
  2. 块索引
  3. 指向文件信息的一些指针，实际内容存储在内存中的磁盘镜像的对应块里
- 方法包括
  1. 根据数据成员中的指向文件信息的一些指针，从内存中的磁盘镜像的对应块里得到文件信息
  2. 根据数据成员中的指向文件信息的一些指针，向内存中的磁盘镜像的对应块里写入文件信息

![FCBp.drawio](%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/FCBp.drawio.png)

```cpp
struct FCBp
{
public:
	//默认构造函数
	explicit FCBp() = default;
	explicit FCBp(byte* p);
	//根据块索引、磁盘内存镜像头指针，从索引对应的块建立FCB结构体
	explicit FCBp(byte* p, index_t ind);
	//根据块索引、磁盘内存镜像头指针、需要在磁盘上建立的FCB的信息，在索引对应的块上写入FCB
	explicit FCBp(byte* p, index_t ind, const char fn[], byte isdir, time_t updtime, index_t father, uint32_t size);


	FCBp(const FCBp& f) = default;

	byte*   ptr   = nullptr; // 块起始地址
	index_t index = 0;       // 第几块

	// 数据共 1024 B
	char*     p_file_name  = nullptr; // 113 = FILESYS_FILENAME_MAXLEN*1B
	char*     p_isdir      = nullptr; // 1*1B，为0是普通文件，为1是目录
	time_t*   p_updtime    = nullptr; // 1*8B, 更新时间
	index_t*  p_father     = nullptr; // 1*2B，为文件的父目录，根目录的父目录为0
	uint32_t* p_size       = nullptr; // 1*4B，文件大小（字节）
	index_t*  p_nodeindexs = nullptr; // 896B = FILESYS_BLK_INDEX_NUM*2B
	// 0 代表 空
	// p_isdir == 0 时，
	//		p_nodeindexs 存储文件块索引，一级索引，文件最大244KB
	// p_isdir == 1  时，
	//		p_nodeindexs 存储FCB所在块索引，文件个数最多为224

	//index_t find_1_avail_entrance();

	
	const char* file_name() const;              //从内存中的磁盘镜像读取文件名
	void        set_file_name(const char fn[]); //设置新文件名到内存中的磁盘镜像
	char        isdir() const;                  //从内存中的磁盘镜像读取是否为文件夹
	void        set_isdir(char isdir);          //设置新的是否文件夹到内存中的磁盘镜像
	time_t      updtime() const;                //从内存中的磁盘镜像读取最近修改时间
	void        set_updtime(time_t updtime);    //设置新的修改时间到内存中的磁盘镜像
	index_t     father() const;                 //从内存中的磁盘镜像读取上级目录
	void        set_father(index_t father);     //设置新的上级目录到内存中的磁盘镜像
	uint32_t    size() const;                   //从内存中的磁盘镜像读取文件大小
	void        set_size(uint32_t size);        //设置新文件大小到内存中的磁盘镜像
	index_t*    nodeindexs() const;             //从内存中的磁盘镜像读取FCB内含的索引


};
```



#### FilePath

记录路径，目前只用于记录 `cwd (current working folder)` 当前所在文件夹。

每一级文件夹的 `string` 单独保存，根目录为空字符串。

例如：形如 `"/usr/home/document"`  的路径，其 `FilePath.data` 为 `{"", "usr", "home", "document"}` ； `get()` 方法返回字符串 `/usr/home/document/` 。

```cpp
struct FilePath
{
	vector<string> data;   //每一级文件夹的string单独保存,根目录为空字符串
	string         get();  //得到形如"/dir1/dir2/dir3/"的字符串
	string         last(); //得到最内层的文件夹名

	FilePath& operator+=(const string& fn); // 进入一层
	FilePath& operator--();                 // 退出一层
};
```



#### FileSys

实现文件系统。具体接口与功能说明可见下面代码的注释

```cpp
class FileSys
{
public:
	FileSys(const string& fsn);
	~FileSys();
	//按new时提供的名称保存，智能添加文件扩展名.mfsimg
	bool                   save() { return save(fs_name); } 
	bool                   save(string img_name);
    //根据名称加载镜像，返回一个根据该镜像新创建的FileSys对象指针
	static FileSys*        load(string img_name);      
    //根据名称新建镜像，返回一个根据该镜像新创建的FileSys对象指针
	static FileSys*        newfsys(const string& fsn); 
	int                    mkdir(const string& fn);
	int                    rmdir(const string& fn); //删除文件夹
	vector<vector<string>> ls();
	int                    cd(const string& ss);
	int                    create(const string& fn);
	int                    open(const string& fn);
	int                    close(int fd);
	vector<byte>           read(int fd);
	int                    write(int fd, const string& str); //覆盖写
	int                    del(const string& fn);            //删除文件

	int    is_fd_open(int fd);
	string get_cwd_str(); //方便外部读取cwd

protected:
	bool _cd(const string& fn);                 //相对路径cd
	bool _newfile(const string& fn, bool dir);  //因为mkdir和create很像，所以为了代码复用写了这个函数
	bool _refresh_cwd_FCB_cache(index_t index); //更新cwd中所含文件的FCB缓存

	inline bool    _is_blk_used(index_t index); //利用bitmap判断块是否被占用
	inline void    _set_blk_used(index_t index);//设置bitmap中块被占用
	inline void    _set_blk_unused(index_t index);//设置bitmap中块可用
	inline void    _clear_blk(index_t index);   //清除block内容
	inline index_t _find_1_avail_blk_front();//从前往后开始扫描bitmap，找到一个可用的块，找不到就返回0
	inline index_t _find_next_1_blk_back();  //从后往前开始扫描bitmap，找到一个可用的块，找不到就返回0
	inline int     _find_1_avail_fd();       //寻找一个可用的fd号。返回0即为没有可用的了

	inline static bool is_legal_fn(const string& fn);       //判断文件名是否合法
	inline static bool is_legal_fn_slash(const string& fn); //判断文件名是否合法，合法字符多一个'/'
	inline static bool is_legal_path(const string& p);      //判断路径是否合法


	//FCBp& get_FCB_from_index(const index_t index) const {}

	const unsigned char MASK[8] = {
		0b10000000u, 0b01000000u,
		0b00100000u, 0b00010000u,
		0b00001000u, 0b00000100u,
		0b00000010u, 0b00000001u
	}; //bitmap相关掩码

	unsigned char bitmap[FILESYS_BLKS_NUM / 8]{};   //存放bitmap的数组
	byte          MFileImg[FILESYS_CAPACITY_BYTES]{}; //内存中的磁盘镜像
	FilePath      cwd;                              //当前所在文件夹路径
	FCBp          cwdFCB;                           //当前所在文件夹的FCB
	FCBp          FCB_in_cwd[FILESYS_BLK_INDEX_NUM];//当前所在文件夹内文件的FCB缓存
	vector<FCBp>  open_file_list; //已打开文件的FCB, 0号默认是根目录
	string        fs_name;        //当前文件系统的名字，用于保存和读取文件系统镜像
};
```





### **符号**



#### **FileSys.h**

所有内容均在 `namespace MF` 内



##### *全局常量*

```cpp
constexpr size_t FILESYS_BLK_INDEX_NUM  = 448;     // 每个FCB可容纳多少个索引项目
constexpr size_t FILESYS_BLK_SIZE_BYTES = 1 << 10; // 块大小，1 KB
constexpr size_t FILESYS_BLKS_NUM       = 1 << 12; // 块总数，4096 blocks
constexpr size_t FILESYS_CAPACITY_BYTES = FILESYS_BLK_SIZE_BYTES
					* FILESYS_BLKS_NUM; // 文件系统大小，4 MB, 不含bitmap的512B
constexpr size_t FILESYS_FILENAME_MAXLEN = 113;    // 文件名最大长度，including '\0'
constexpr size_t FILESYS_FILE_MAXLEN     = FILESYS_BLK_INDEX_NUM 
    				* FILESYS_BLK_SIZE_BYTES; // 文件最大大小，448 KB
constexpr size_t FILESYS_FD_MAX          = 128; //最多同时打开128个文件
```



##### *类型别名*

```cpp
using byte = unsigned char; // 用于表示磁盘最小表示单元，byte
using index_t = uint16_t;   // 用于表示索引项。因为块总数为4096，所以2字节长的无符号整数 0-65535 足够使用。
```



##### *`struct FCBp`*

详细请见 上文 [数据结构说明处代码内的注释](#FCBp)

##### *`struct FilePath`*

详细请见 上文 [数据结构说明处代码内的注释](#FilePath)

##### *`class FileSys`*

详细请见 上文 [数据结构说明处代码内的注释](#FileSys)



#### utils.h

该头文件声明了一些与文件系统没有直接关系的实用函数。所有内容均在 `namespace MF` 内。

```cpp
std::vector<std::string> split(const std::string& text, char sep); //实现字符串分割，string.split()
std::time_t              local_time_now();                         //得到当前时间
std::string              time2string(std::time_t tt);              //把时间转为字符串
bool                     is_number(const std::string& s);          //判断一个字符串是否是整数

```

#### main.cpp

主函数在该文件中。主函数内解析输入并转化为相应命令，按需新建 `FileSys` 对象，调用 `FileSys` 实例的相关方法，并把结果输出。

```cpp
string c, a, b;//c是每行第一个输入参数，即命令名；a和b是第二、三个输入参数，按需读取。

FileSys* ffs = nullptr;//指向文件系统对象的指针。按需新建对象。

int mode = 0;//模式，0=加载新建文件系统镜像(new, sfs)，1=文件系统内操作(包含exit)
```

#### test.cpp

测试一些代码片段是否符合预期时使用。现在为空，没有实际内容。



## **II. 算法流程与设计说明**



### **整体设计**

本项目使用语言标准为 `C++14` 与 `C11` ，编译器为 `msvc v143` ，工程文件对应 IDE 为 Visual Studio 2022 。



- 文件结构为：索引结构，**索引表**存放在文件的 `FCB` 里；
  - 有两类文件，一类为普通文件，一类为目录文件；
  - 普通文件FCB索引项记录文件体所在块号，0 代表空记录
  - 目录文件FCB索引项记录该目录下所有文件的FCB所在块号，0 代表空记录
  - 一个 `FCB` 中可容纳 448 个索引
  - 0 号块存放根目录的FCB
- 文件的目录结构为：多级目录——树形目录结构；做很简单的修改后可以实现无环图目录结构。
  - 设计了 `cwd` 当前工作目录的内含文件的FCB缓存（ `FCB_in_cwd` ），方便检索文件。
- 文件分为：文件体（分块存储），FCB（占用 1 块）
  - 基本文件名（含扩展名）最大长度为 `112` ，不含字符串结束的 `'\0'` ；
  - 合法文件名只能由 **大小写字母、数字和英文句点`'.'`** 组成，**除根目录外文件名不能为空**
- 空间布局与管理方法为：位示图 `bitmap`
  - 磁盘镜像大小为 `4 MB` ，分为 `4096` 块，块大小为 `1 KB` 
  - `bitmap ` 大小为`512B`
  - 文件系统空间最小分配单位为 1 块

### **处理流程**



#### save

按new时提供的名称保存，智能添加文件扩展名 `.mfsimg` ，以二进制形式直接把 `MFileImg` 、 `bitmap` 写入文件。

```cpp
bool                   save() { return save(fs_name); }
bool                   save(string img_name);

bool FileSys::save(string img_name) {
	if (img_name.size() > 7 &&
	    img_name.substr(img_name.size() - 7, 7) == ".mfsimg");
	//如果没有拓展名就加上
	else { img_name += ".mfsimg"; }
	std::ofstream bfo(img_name, std::fstream::out | std::fstream::binary);
	if (bfo.is_open()) {
		//保存MFileImg和bitmap到硬盘
		bfo.write(reinterpret_cast<const char*>(MFileImg), FILESYS_CAPACITY_BYTES);
		bfo.write(reinterpret_cast<const char*>(bitmap), sizeof(bitmap));
		if (bfo.good()) {
			std::cerr << "Info:\t file system \"" + fs_name + "\""
					+ " saved as \"" + img_name + "\"" << std::endl;
			return true;
		}
	}
	std::cerr << "Error:\t failed to save this file system" << std::endl;
	return false;
}
```

#### load，即 sfs

静态方法。按名称读取镜像文件，创建新 `FileSys` 对象，从镜像文件读取 `MFileImg` 、 `bitmap` 到新对象中，并进入根目录，刷新 `cwd` 缓存，返回该新对象指针。

```cpp
//根据名称加载镜像，返回一个根据该镜像新创建的FileSys对象指针
static FileSys*        load(string img_name);   

FileSys* FileSys::load(string img_name) {
	//文件如果有拓展名
	if (img_name.size() > 7 &&
	    img_name.substr(img_name.size() - 7, 7) == ".mfsimg");
	//如果没有拓展名就加上
	else { img_name += ".mfsimg"; }
	auto          ptr = new FileSys(img_name);
	std::ifstream bfi(img_name, std::fstream::in | std::fstream::binary);
	if (bfi.is_open()) {
		bfi.read(reinterpret_cast<char*>(ptr->MFileImg), FILESYS_CAPACITY_BYTES);
		bfi.read(reinterpret_cast<char*>(ptr->bitmap), sizeof(ptr->bitmap));
		if (bfi.good()) {
			//刷新cwd与相关缓存
			ptr->cd("/");
			return ptr;
		}
	}
	std::cerr << "Error:\t failed to load this file system" << std::endl;
	return nullptr;
}
```

#### newsfs，即 new

静态方法。直接创建新的 `FileSys` 对象，返回其指针，供后续使用。

```cpp
//根据名称新建镜像，返回一个根据该镜像新创建的FileSys对象指针
static FileSys*        newfsys(const string& fsn); 

FileSys* FileSys::newfsys(const string& fsn) { return (new FileSys(fsn)); }
```

#### mkdir 与 create，及其内部实现 _newfile()

因为 `mkdir` 和 `create` 很相似，所以为了代码复用，共用一个内部实现 `_newfile()`

 `_newfile()` 实现流程如下：首先判断文件名是否合法，然后找当前工作目录FCB的空闲索引项（同时检查当前工作目录是否有与之重名的文件），然后寻找 1 个空闲磁盘块存放新文件FCB，再写入把块号写入之前找到的空闲索引项，最后更新当前工作目录所含文件的FCB缓存（ `FCB_in_cwd` ）。

```cpp
int                    mkdir(const string& fn);
int                    create(const string& fn);
//因为mkdir和create很像，所以为了代码复用写了这个函数
bool                   _newfile(const string& fn, bool dir);  

int FileSys::mkdir(const string& fn) {
	return _newfile(fn, true);
}

int FileSys::create(const string& fn) { 
    return _newfile(fn, false); 
}

bool FileSys::_newfile(const string& fn, bool dir) {
	//判断文件名是否合法
	if (!is_legal_fn(fn)) {
		std::cerr << "Error:\t illegal file name" << std::endl;
		return false;
	}
	int  avalentry = 0, i = 0;
	bool found     = false;
	//先找cwd的FCB的空闲条目
	for (const auto& f : FCB_in_cwd) {
		if (f.index == 0) {
			avalentry = (found) ? avalentry : i; //FCB里找第一个空条目
			found     = true;
			continue;
		}
		if (fn == f.file_name()) {
			std::cerr << "Error:\t a file with same name exists in cwd" << std::endl;
			return false;
		}
		++i;
	}
	//再找空闲磁盘块存放新文件的FCB
	auto avalblk = _find_1_avail_blk_front();
	if (!found) {
		std::cerr << "Error:\t this dir is full" << std::endl;
		return false;
	}
	if (avalblk == 0) {
		std::cerr << "Error:\t no space on this filesystem" << std::endl;
		return false;
	}
	//创建新文件FCB，写入块，更新cwdFCB，并更新cwdFCB包含的条目
	_set_blk_used(avalblk);
	FCB_in_cwd[avalentry]          = FCBp(MFileImg, avalblk, fn.data(), dir, local_time_now(), cwdFCB.index, 0);
	cwdFCB.nodeindexs()[avalentry] = avalblk;
	return true;
}
```

#### rmdir

在当前工作目录缓存寻找与提供文件名相同的文件FCB，根据其内含索引项是否全为 0 判断是否为空，为空则可以删除；得到该文件FCB内的index块号（文件FCB所在块号），首先清除上级目录（当前工作目录）FCB内相关索引项，再根据块号清空磁盘内对应文件FCB所在块，最后清除对应文件的FCB缓存（ `FCB_in_cwd` ）。

```cpp
int                    rmdir(const string& fn); //删除文件夹

int FileSys::rmdir(const string& fn) {
	if (!is_legal_fn(fn)) {
		std::cerr << "Error:\t illegal file name" << std::endl;
		return false;
	}
	for (auto& f : FCB_in_cwd) {
		//跳过空块
		if (f.index == 0)continue;
		//找到对应FCB！而且是文件夹
		if (f.file_name() == fn && f.isdir() == 1) {
			//如果文件夹里面还有文件则不能删除
			for (int i = 0; i < FILESYS_BLK_INDEX_NUM; ++i) {
				auto z = f.nodeindexs()[i];
				if (z != 0) {
					std::cerr << "Error:\t cannot delete non-empty dir" << std::endl;
					return false;
				}
			}
			//清除上级目录FCB内的入口
			auto pt = cwdFCB.nodeindexs();
			for (int i = 0; i < FILESYS_BLK_INDEX_NUM; ++i) {
				if (pt[i] == f.index) {
					pt[i] = 0;
					break;
				}
			}
			//清除磁盘内对应文件的FCB
			_clear_blk(f.index);
			f.index = 0;
			//清除对应文件的FCB缓存
			f = FCBp();
			return true;
		}
	}
	std::cerr << "Error:\t no such file" << std::endl;;
	return false;
}
```

#### ls

从当前工作目录内含文件的FCB缓存（ `FCB_in_cwd` ）里获取文件信息（文件名，最后修改时间，文件大小），处理成字符串，打包成 `vector` 返回

```cpp
vector<vector<string>> ls();

vector<vector<string>> FileSys::ls() {
	vector<vector<string>> ret;
	for (const auto& f : FCB_in_cwd) {
		if (f.index == 0)continue;
		auto s = string(f.file_name());
		//若是文件夹则在名字后面附带一个"/"
		if (f.isdir())s += "/";
		auto ttt = f.updtime();
		ret.emplace_back(vector<string>{s, std::to_string(f.size()), time2string(ttt)});
	}
	return ret;
}

```

#### cd

对于一次一级的相对路径（如 `cd dir` 或 `cd ..` ）：如果是返回上一级目录（ `cd ..` ），则获取当前工作目录的父目录索引号，根据该索引号找到父目录FCB所在块，然后用这个FCB更新当前工作目录FCB（ `cwdFCB` ），更新当前工作目录路径记录（ `cwd` ），更新当前工作目录内含文件的FCB缓存（ `FCB_in_cwd` ）；否则首先确认目录名是否合法，如果合法则首先在当前目录下寻找对应目录，用新目录的FCB更新 `FileSys` 保存的当前工作目录FCB（ `cwdFCB` ），更新当前工作目录路径记录（ `cwd` ），更新当前工作目录内含文件的FCB缓存（ `FCB_in_cwd` ）。

对于绝对路径（未经过测试，不保证能正常工作）：如果是进入根目录（ `cd /` ），则直接进入，然后刷新 `cwd, cwdFCB, FCB_in_cwd `；否则检查路径名是否合法，逐级以相对路径的方式进入。

```cpp
int                    cd(const string& ss);
bool                   _cd(const string& fn);    

int FileSys::cd(const string& ss) {
	//相对路径（一次进一个文件夹）
	if (ss[0] != '/') {
		//cd ..返回上一级
		if (ss.size() == 2 && ss[0] == '.' && ss[1] == '.' ||
		    ss.size() == 3 && ss[0] == '.' && ss[1] == '.' && ss[2] == '/') {
			if (cwdFCB.index == 0) {
				std::cerr << "Error:\t already in root" << std::endl;
				return false;
			}
			//更新cwd和cwd内含文件的FCB缓存
			_refresh_cwd_FCB_cache(cwdFCB.father());
			//更新cwd路径记录
			--cwd;
			return true;
		}
		//判断文件名合法
		if (is_legal_fn(ss))
		//真正的cd
			return _cd(ss);
		else {
			std::cerr << "Error:\t illegal path" << std::endl;
			return false;
		}
	}
	//todo
	//绝对路径（"/aa/ss/cc/"或"/aa/xx/ss"）
	else {
		//特判'cd /'
		if (ss.size() == 1 && ss == "/") {
			cwd = FilePath();
			cwd += "";
			_refresh_cwd_FCB_cache(0);
			return true;
		}
		//初步检查路径合法后依次进入下一层，即没有连着的"/"
		auto vss = split(ss, '/');
		for (int i = 0; i < ss.size(); ++i) {
			if (vss[i].size() == 0 && !(i == 0 || i == vss.size() - 1)) {
				std::cerr << "Error:\t illegal path" << std::endl;
				return false;
			}
		}
		int z = vss.back().size() == 0 ? 1 : 0;
		for (int i = 1; i < vss.size() - z; ++i) { if (!_cd(vss[i])) { return false; } }
	}
}

bool FileSys::_cd(const string& fn) {
	if (!is_legal_fn(fn)) {
		std::cerr << "Error:\t illegal path" << std::endl;
		return false;
	}
	for (const auto& s : FCB_in_cwd) {
		//跳过空条目
		if (s.index == 0)continue;
		//文件名相同且为文件夹
		if (fn == s.file_name() && s.isdir()) {
			//更新cwd
			//更新cwd指向的FCB
			_refresh_cwd_FCB_cache(s.index);
			//更新cwd路径记录
			cwd += fn;
			return true;
		}
	}
	std::cerr << "Error:\t no such path existed" << std::endl;
	return false;
}
```

#### open

根据文件名，在当前工作目录缓存中寻找对应文件，找到对应文件且不是文件夹后在已打开文件列表（ `open_file_list` ）中检查是否已经打开，若已经打开则返回相应 `fd` ，否则在已打开文件列表里找一个空位存该文件的 `FCBp`，返回这个空位的下标。

```cpp
int                    open(const string& fn);

int FileSys::open(const string& fn) {
	int fd = 0;
	if (!is_legal_fn(fn)) {
		std::cerr << "Error:\t illegal file name" << std::endl;
		return false;
	}
	for (auto& f : FCB_in_cwd) {
		//跳过空块
		if (f.index == 0)continue;
		//找到对应FCB！而且不是文件夹
		if (f.file_name() == fn && f.isdir() == 0) {
			//文件还未被打开,若打开则返回那个fd
			for (int i = 1; i < FILESYS_FD_MAX; ++i) {
				auto& ff = open_file_list[i];
				if (ff.index == 0)continue;
				if (ff.index == f.index) {
					std::cerr << "Error:\t file is already open" << std::endl;
					return i;
				}
			}
			for (int i = 1; i < FILESYS_FD_MAX; ++i) {
				auto& ff = open_file_list[i];
				if (ff.index == 0) {
					ff = f;
					return i;
				}
			}
		}
	}
	std::cerr << "Error:\t no such file in cwd" << std::endl;
	return 0;
}
```

#### close

根据 `fd` ，在已打开文件列表中找到下标为 `fd` 的FCB，若 `index` 为 0 ，则代表这个位置是空的，报错；否则清空该位置。

```cpp
int                    close(int fd);

int FileSys::close(int fd) {
	if (!(fd > 0 && fd < FILESYS_FD_MAX && open_file_list[fd].index != 0)) {
		std::cerr << "Error:\t fd error" << std::endl;
		return false;
	}
	open_file_list[fd] = FCBp();
	open_file_list[fd].index = 0;
	return true;
}
```

#### read

首先检查 `fd` 在范围内且对应一个已经打开的文件（已打开文件列表中找到下标为 `fd` 的FCB，若 `index` 为 0 ，则代表这个位置是空的），然后根据欲读取文件的FCB中记录的块索引，把所有不为0的索引对应的块内容依次读取，同时每读 1 字节计数器 cnt 自增 1 ，直到计数器 cnt 等于 FCB 中记录的文件大小。

```cpp
vector<byte>           read(int fd);

vector<byte> FileSys::read(int fd) {
	//fd在范围内且已经打开
	if (!(fd > 0 && fd < FILESYS_FD_MAX && open_file_list[fd].index != 0)) {
		std::cerr << "Error:\t fd error" << std::endl;
		return {};
	}
	auto&           s    = open_file_list[fd];
	int             size = s.size();
	vector<byte>    ret(size, 0);
	vector<index_t> blks;
	int             cnt = 0;
	//一块一块读到vector<byte>里
	for (int i = 0; i < FILESYS_BLK_INDEX_NUM; i++) {
		index_t ind = s.nodeindexs()[i];
		if (ind != 0) {
			for (int i = 0; i < FILESYS_BLK_SIZE_BYTES; ++i) {
				if (cnt < size) {
					ret[cnt] = MFileImg[ind * FILESYS_BLK_SIZE_BYTES + i];
					++cnt;
				}
				else return ret;
			}
		}
	}

	if (cnt < size)std::cerr << "Warning:\t file real size is NOT equal to FCBp" << std::endl;
	return ret;
}
```

#### write

覆盖写。根据写入字符串，计算得到所需块数（向上取整），若大小超过单文件长度限制则报错，若找不够需要的空闲块则报错，依次写入块，并用写入块的块号更新文件FCB内的索引

```cpp
int                    write(int fd, const string& str); //覆盖写

int FileSys::write(int fd, const string& str) {
	//fd在范围内且已经打开
	if (!(fd > 0 && fd < FILESYS_FD_MAX && open_file_list[fd].index != 0)) {
		std::cerr << "Error:\t fd error" << std::endl;
		return {};
	}
	auto& f = open_file_list[fd];
	size_t size = str.size() + 1;
	//超出单文件长度限制
	if (size > FILESYS_FILE_MAXLEN) {
		std::cerr << "Error:\t exceed max file length" << std::endl;
		return false;
	}
	//找到供写入的块
	vector<index_t> blks;
	while (blks.size() < std::ceil((double)size / (double)FILESYS_BLK_SIZE_BYTES)) {
		auto t = _find_1_avail_blk_front();
		//找不够，则返还这些块
		if (t == 0) {
			std::cerr << "Error:\t no enough space for this file" << std::endl;
			for (auto i : blks)_set_blk_unused(i);
			return false;
		}
		blks.push_back(t);
		_set_blk_used(t);
	}
	//FCB记录文件大小
	f.set_size(size);
	//依次把文件内容写入块
	size_t now = 0, end = 0;
	for (int i = 0; i < blks.size(); ++i) {
		end    = std::min(now + FILESYS_BLK_SIZE_BYTES, size);
		auto z = blks[i] * FILESYS_BLK_SIZE_BYTES;
		//memcpy(MFileImg + z, str.data() + now, end - now);
		for (int ii = now; ii < end; ++ii) { MFileImg[z + ii] = str[now + ii]; }
		now               = end;
		f.nodeindexs()[i] = blks[i];
	}
	return true;
}

```

#### del，即 delete

检查文件名是否合法，在当前工作目录找到对应FCB（且不是文件夹），遍历已打开文件列表以确认文件未打开，通过所有检查则：先依次清除FCB内非 0 索引项对应块（清除所有存储文件内容的块），再清除上级目录（cwd）FCB内该文件的索引项，然后清空磁盘内该文件的FCB所在块，最后清除FCB缓存。

```cpp
int                    del(const string& fn);            //删除文件

int FileSys::del(const string& fn) {
	if (!is_legal_fn(fn)) {
		std::cerr << "Error:\t illegal file name" << std::endl;
		return false;
	}
	for (auto& f : FCB_in_cwd) {
		//跳过空块
		if (f.index == 0)continue;
		//找到对应FCB！而且不能是文件夹
		if (f.file_name() == fn && f.isdir() == 0) {
			//文件未open?
			for (auto& ff : open_file_list) {
				if (f.index == ff.index) {
					std::cerr << "Error: cannot delete open file" << std::endl;
					return false;
				}
			}
			//依次清除所有存储文件内容的block
			for (int i = 0; i < FILESYS_BLK_INDEX_NUM; ++i) {
				auto z = f.nodeindexs()[i];
				if (z != 0) {
					_clear_blk(z);
					_set_blk_unused(z);
				}
			}
			//清除上级目录FCB内的入口
			auto pt = cwdFCB.nodeindexs();
			for (int i = 0; i < FILESYS_BLK_INDEX_NUM; ++i) {
				if (pt[i] == f.index) {
					pt[i] = 0;
					break;
				}
			}
			//清除磁盘内对应文件的FCB
			_clear_blk(f.index);
			//清除对应文件的FCB缓存
			f = FCBp();

			return true;
		}
	}
	std::cerr << "Error:\t file not found" << std::endl;
	return false;
}
```







### **重要模块的详细设计、功能和接口说明**

关于 `FCBp` 、`FilePath` 、 `FileSys` ，请见 上文 [数据结构说明处正文及代码内的注释](#FCBp)

关于 `utils.h` 内的实用函数，请见 上文 [utils.h](#utils.h)

关于 `FileSys` 接口如何实现，请见 上文 [处理流程](#处理流程)



## **III. 源程序（附注释）**



#### FileSys.h

```cpp
#pragma once
#include <string>
//#include <ctime>
#include <chrono>
//#include <cstring>
#include <iostream>
#include <fstream>
#include <memory>
#include <vector>

#include "utils.h"

#define MF_ASSIGN_INDEAD_OF_MEMCPY true

namespace MF
{
using std::string;
//using std::time;
using std::shared_ptr;
using std::unique_ptr;
using std::weak_ptr;
using std::make_shared;
using std::make_unique;
using std::vector;


constexpr size_t FILESYS_BLK_INDEX_NUM  = 448;
constexpr size_t FILESYS_BLK_SIZE_BYTES = 1 << 10; // 1 KB
constexpr size_t FILESYS_BLKS_NUM       = 1 << 12; // 4096 blocks
constexpr size_t FILESYS_CAPACITY_BYTES = FILESYS_BLK_SIZE_BYTES
                                          * FILESYS_BLKS_NUM; // 4 MB, 不含bitmap的512B
constexpr size_t FILESYS_FILENAME_MAXLEN = 113;               // including '\0'
constexpr size_t FILESYS_FILE_MAXLEN     = FILESYS_BLK_INDEX_NUM * FILESYS_BLK_SIZE_BYTES;
constexpr size_t FILESYS_FD_MAX          = 128; //最多同时打开128个文件

using byte = unsigned char; // 用于表示磁盘最小表示单元，byte
using index_t = uint16_t;   // 用于表示索引项。因为块总数为4096，所以2字节长的无符号整数 0-65535 足够使用。

//确保长度正确，必须为64位程序
static_assert(
	sizeof(uint32_t) == 4 &&
	sizeof(uint16_t) == 2 &&
	sizeof(uint64_t) == 8 &&
	sizeof(byte) == 1 &&
	sizeof(size_t) == 8 &&
	sizeof(void*) == 8 &&
	sizeof(time_t) == 8 &&
	sizeof(bool) == 1 &&
	sizeof(index_t) == 2,
	"type length ERROR"
);


//FCBp 是一个类似FCB的结构体，但是并不实际存储FCB的内容
struct FCBp
{
public:
	//默认构造函数
	explicit FCBp() = default;
	explicit FCBp(byte* p);
	//根据块索引、磁盘内存镜像头指针，从索引对应的块建立FCB结构体
	explicit FCBp(byte* p, index_t ind);
	//根据块索引、磁盘内存镜像头指针、需要在磁盘上建立的FCB的信息，在索引对应的块上写入FCB
	explicit FCBp(byte* p, index_t ind, const char fn[], byte isdir, time_t updtime, index_t father, uint32_t size);


	FCBp(const FCBp& f) = default;

	byte*   ptr   = nullptr; // 块起始地址
	index_t index = 0;       // 第几块

	// 数据共 1024 B
	char*     p_file_name  = nullptr; // 113 = FILESYS_FILENAME_MAXLEN*1B
	char*     p_isdir      = nullptr; // 1*1B，为0是普通文件，为1是目录
	time_t*   p_updtime    = nullptr; // 1*8B, 更新时间
	index_t*  p_father     = nullptr; // 1*2B，为文件的父目录，根目录的父目录为0
	uint32_t* p_size       = nullptr; // 1*4B，文件大小（字节）
	index_t*  p_nodeindexs = nullptr; // 896B = FILESYS_BLK_INDEX_NUM*2B
	// 0 代表 空
	// p_isdir == 0 时，
	//		p_nodeindexs 存储文件块索引，一级索引，文件最大244KB
	// p_isdir == 1  时，
	//		p_nodeindexs 存储FCB所在块索引，文件个数最多为224

	//index_t find_1_avail_entrance();


	const char* file_name() const;              //从内存中的磁盘镜像读取文件名
	void        set_file_name(const char fn[]); //设置新文件名到内存中的磁盘镜像
	char        isdir() const;                  //从内存中的磁盘镜像读取是否为文件夹
	void        set_isdir(char isdir);          //设置新的是否文件夹到内存中的磁盘镜像
	time_t      updtime() const;                //从内存中的磁盘镜像读取最近修改时间
	void        set_updtime(time_t updtime);    //设置新的修改时间到内存中的磁盘镜像
	index_t     father() const;                 //从内存中的磁盘镜像读取上级目录
	void        set_father(index_t father);     //设置新的上级目录到内存中的磁盘镜像
	uint32_t    size() const;                   //从内存中的磁盘镜像读取文件大小
	void        set_size(uint32_t size);        //设置新文件大小到内存中的磁盘镜像
	index_t*    nodeindexs() const;             //从内存中的磁盘镜像读取FCB内含的索引

private:
};

struct FilePath
{
	vector<string> data;   //每一级文件夹的string单独保存,根目录为空字符串
	string         get();  //得到形如"/dir1/dir2/dir3/"的字符串
	string         last(); //得到最内层的文件夹名

	FilePath& operator+=(const string& fn); // 进入一层
	FilePath& operator--();                 // 退出一层
};

class FileSys
{
public:
	FileSys(const string& fsn);
	~FileSys();

	bool                   save() { return save(fs_name); } // 按new时提供的名称保存，智能添加文件扩展名.mfsimg
	bool                   save(string img_name);
	static FileSys*        load(string img_name);      //根据名称加载镜像，返回一个根据该镜像新创建的FileSys对象指针
	static FileSys*        newfsys(const string& fsn); //根据名称新建镜像，返回一个根据该镜像新创建的FileSys对象指针
	int                    mkdir(const string& fn);
	int                    rmdir(const string& fn); //删除文件夹
	vector<vector<string>> ls();
	int                    cd(const string& ss);
	int                    create(const string& fn);
	int                    open(const string& fn);
	int                    close(int fd);
	vector<byte>           read(int fd);
	int                    write(int fd, const string& str); //覆盖写
	int                    del(const string& fn);            //删除文件

	int    is_fd_open(int fd);
	string get_cwd_str(); //方便外部读取cwd

protected:
	bool _cd(const string& fn);                 //相对路径cd
	bool _newfile(const string& fn, bool dir);  //因为mkdir和create很像，所以为了代码复用写了这个函数
	bool _refresh_cwd_FCB_cache(index_t index); //更新cwd中所含文件的FCB缓存
	//bool _is_open(const string& fn);            //判断文件是否在已打开文件列表里

	inline bool    _is_blk_used(index_t index) const; //利用bitmap判断块是否被占用
	inline void    _set_blk_used(index_t index);      //设置bitmap中块被占用
	inline void    _set_blk_unused(index_t index);    //设置bitmap中块可用
	inline void    _clear_blk(index_t index);         //清除block内容
	inline index_t _find_1_avail_blk_front();         //从前往后开始扫描bitmap，找到一个可用的块，找不到就返回0
	inline index_t _find_next_1_blk_back();           //从后往前开始扫描bitmap，找到一个可用的块，找不到就返回0
	inline int     _find_1_avail_fd();                //寻找一个可用的fd号。返回0即为没有可用的了

	inline static bool is_legal_fn(const string& fn);       //判断文件名是否合法
	inline static bool is_legal_fn_slash(const string& fn); //判断文件名是否合法，合法字符多一个'/'
	inline static bool is_legal_path(const string& p);      //判断路径是否合法


	//FCBp& get_FCB_from_index(const index_t index) const {}

	const unsigned char MASK[8] = {
		0b10000000u, 0b01000000u,
		0b00100000u, 0b00010000u,
		0b00001000u, 0b00000100u,
		0b00000010u, 0b00000001u
	}; //bitmap相关掩码

	unsigned char bitmap[FILESYS_BLKS_NUM / 8]{};     //存放bitmap的数组
	byte          MFileImg[FILESYS_CAPACITY_BYTES]{}; //内存中的磁盘镜像
	FilePath      cwd;                                //当前所在文件夹路径
	FCBp          cwdFCB;                             //当前所在文件夹的FCB
	FCBp          FCB_in_cwd[FILESYS_BLK_INDEX_NUM];  //当前所在文件夹内文件的FCB缓存
	vector<FCBp>  open_file_list;                     //已打开文件的FCB, 0号默认是根目录
	string        fs_name;                            //当前文件系统的名字，用于保存和读取文件系统镜像
};
}

```

#### utils.h

```cpp
#pragma once
#include <string>
#include <vector>
#include <chrono>
#include <iomanip>
#include <sstream>

namespace MF
{
//using std::vector;
//using std::string;

std::vector<std::string> split(const std::string& text, char sep); //实现字符串分割，string.split()
std::time_t              local_time_now();                         //得到当前时间
std::string              time2string(std::time_t tt);              //把时间转为字符串
bool                     is_number(const std::string& s);          //判断一个字符串是否是整数
}

```

#### FileSys.cpp

```cpp
#include "FileSys.h"
#include <cassert>

namespace MF
{
//FCBp::FCBp(byte* p) : FCBp(p, 0) {
//}

FCBp::FCBp(byte* p, index_t ind)
	: ptr(p + ind * FILESYS_BLK_SIZE_BYTES),
	  index(ind),
	  p_file_name(reinterpret_cast<decltype(p_file_name)>(ptr)),
	  p_isdir(reinterpret_cast<decltype(p_isdir)>(ptr + FILESYS_FILENAME_MAXLEN)),
	  p_updtime(reinterpret_cast<decltype(p_updtime)>(ptr + (FILESYS_FILENAME_MAXLEN + 1))),
	  p_father(reinterpret_cast<decltype(p_father)>(ptr + (FILESYS_FILENAME_MAXLEN + 1 + 8))),
	  p_size(reinterpret_cast<decltype(p_size)>(ptr + (FILESYS_FILENAME_MAXLEN + 1 + 8 + 2))),
	  p_nodeindexs(
			  reinterpret_cast<decltype(p_nodeindexs)>(
				  ptr + (FILESYS_FILENAME_MAXLEN + 1 + 8 + 2 + 4))) {

}

FCBp::FCBp(byte*      p, const index_t ind,
           const char fn[], const byte isdir, const time_t updtime, const index_t father, uint32_t size)
	: FCBp(p, ind) {
	assert(strlen(fn) <= FILESYS_FILENAME_MAXLEN - 1);
	memset(p_file_name, 0, FILESYS_FILENAME_MAXLEN);
	memcpy(p_file_name, fn, strlen(fn) + 1);
#if MF_ASSIGN_INDEAD_OF_MEMCPY==true
	*p_isdir   = isdir;
	*p_updtime = updtime;
	*p_father  = father;
	*p_size    = size;
#else
	memcpy(p_isdir, &isdir, decltype(*p_isdir));//1
	memcpy(p_updtime, &updtime, decltype(*p_updtime));//8
	memcpy(p_father, &father, decltype(*p_father));//2
#endif
	memset(p_nodeindexs, 0, FILESYS_BLK_INDEX_NUM * sizeof(decltype(*p_nodeindexs))); //896=448*2
}

//FCBp::FCBp(index_t n_index, const char fn[], const byte dir, const time_t up, const index_t father, uint32_t size)
//	: FCBp(FileSys::p_curMFileImg.get() + n_index, fn, dir, up, father, size) {
//}
//
//
//FCBp::FCBp(index_t n_index, const string& fn, const byte dir, const time_t up, const index_t father, uint32_t size)
//	: FCBp(FileSys::p_curMFileImg.get() + n_index, fn.data(), dir, up, father, size) {
//}

//FCBp::FCBp(FCBp& f): ptr(f.ptr), index(f.index),
//                  p_file_name(f.p_file_name), p_isdir(f.p_isdir), p_updtime(f.p_updtime),
//                  p_father(f.p_father), p_size(f.p_size), p_nodeindexs(f.p_nodeindexs) {
//
//}

//index_t FCBp::find_1_avail_entrance() {
//	for (int i = 0; i < FILESYS_BLK_INDEX_NUM; ++i)
//		if (p_nodeindexs[i] == 0)
//			return i;
//	//todo
//}

const char* FCBp::file_name() const { return reinterpret_cast<const char*>(p_file_name); }

void FCBp::set_file_name(const char fn[]) {
	memset(p_file_name, 0, 115);
	memcpy(p_file_name, fn, strlen(fn) + 1);
}

char FCBp::isdir() const { return *reinterpret_cast<const char*>(p_isdir); }


void FCBp::set_isdir(char isdir) {
#if MF_ASSIGN_INDEAD_OF_MEMCPY==true
	*p_isdir = isdir;
#else
		memcpy(p_isdir, &isdir, 1);
#endif
}

time_t FCBp::updtime() const { return *p_updtime; }

void FCBp::set_updtime(time_t updtime) {
#if MF_ASSIGN_INDEAD_OF_MEMCPY==true
	*p_updtime = updtime;
#else
		memcpy(p_updtime, &updtime, 8);
#endif
}

index_t FCBp::father() const { return *p_father; }

void FCBp::set_father(index_t father) {
#if MF_ASSIGN_INDEAD_OF_MEMCPY==true
	*p_father = father;
#else
		memcpy(p_father, &father, 2);
#endif
}

uint32_t FCBp::size() const { return *p_size; }

void FCBp::set_size(uint32_t size) {
#if MF_ASSIGN_INDEAD_OF_MEMCPY==true
	*p_size = size;
#else
		memcpy(p_size, &size, 4);
#endif
}

index_t* FCBp::nodeindexs() const { return p_nodeindexs; }

//shared_ptr<byte> FileSys::p_curMFileImg{};

//得到绝对路径名
string FilePath::get() {
	string ret;
	for (auto& s : data) {
		ret += s;
		ret += "/";
	}

	return ret;
}

//得到最内层的文件夹名
string FilePath::last() { return data[data.size() - 1]; }

FilePath& FilePath::operator+=(const string& fn) {
	data.push_back(fn);
	return *this;
}

FilePath& FilePath::operator--() {
	if (data.empty()) {
		std::cerr << "Warning:\t path is already root" << std::endl;
		return *this;
	}
	else {
		data.pop_back();
		return *this;
	}
}

FileSys::FileSys(const string& fsn) {
	fs_name = fsn;
	memset(MFileImg, 0, sizeof(MFileImg));
	//FCB_in_cwd = vector<FCBp>(FILESYS_BLK_INDEX_NUM, FCBp());
	for (int i = 0; i < FILESYS_BLK_INDEX_NUM; ++i) { FCB_in_cwd[i] = FCBp(); }
	cwd += "";

	//index_left_avail = 0;
	//index_right_aval = 0;
	//memset(this->MFileImg, 0, sizeof(this->MFileImg));
	//memset(this->bitmap, 0, sizeof(this->bitmap));
	_set_blk_used(0);
	cwdFCB = FCBp(MFileImg, 0, "", true, 0, 0, 0);

	open_file_list    = vector<FCBp>(FILESYS_FD_MAX, FCBp());
	open_file_list[0] = cwdFCB;
}

FileSys::~FileSys() {
	//delete MFileImg;
}

bool FileSys::save(string img_name) {
	if (img_name.size() > 7 &&
	    img_name.substr(img_name.size() - 7, 7) == ".mfsimg");
	//如果没有拓展名就加上
	else { img_name += ".mfsimg"; }
	std::ofstream bfo(img_name, std::fstream::out | std::fstream::binary);
	if (bfo.is_open()) {
		//保存MFileImg和bitmap到硬盘
		bfo.write(reinterpret_cast<const char*>(MFileImg), FILESYS_CAPACITY_BYTES);
		bfo.write(reinterpret_cast<const char*>(bitmap), sizeof(bitmap));
		if (bfo.good()) {
			std::cerr << "Info:\t file system \"" + fs_name + "\""
					+ " saved as \"" + img_name + "\"" << std::endl;
			return true;
		}
	}
	std::cerr << "Error:\t failed to save this file system" << std::endl;
	return false;
}

FileSys* FileSys::load(string img_name) {
	//文件如果有拓展名
	if (img_name.size() > 7 &&
	    img_name.substr(img_name.size() - 7, 7) == ".mfsimg");
	//如果没有拓展名就加上
	else { img_name += ".mfsimg"; }
	auto          ptr = new FileSys(img_name);
	std::ifstream bfi(img_name, std::fstream::in | std::fstream::binary);
	if (bfi.is_open()) {
		bfi.read(reinterpret_cast<char*>(ptr->MFileImg), FILESYS_CAPACITY_BYTES);
		bfi.read(reinterpret_cast<char*>(ptr->bitmap), sizeof(ptr->bitmap));
		if (bfi.good()) {
			//刷新cwd与相关缓存
			ptr->cd("/");
			return ptr;
		}
	}
	std::cerr << "Error:\t failed to load this file system" << std::endl;
	return nullptr;
}

FileSys* FileSys::newfsys(const string& fsn) { return (new FileSys(fsn)); }

int FileSys::mkdir(const string& fn) {
	return _newfile(fn, true);
}

int FileSys::rmdir(const string& fn) {
	if (!is_legal_fn(fn)) {
		std::cerr << "Error:\t illegal file name" << std::endl;
		return false;
	}
	for (auto& f : FCB_in_cwd) {
		//跳过空块
		if (f.index == 0)continue;
		//找到对应FCB！而且是文件夹
		if (f.file_name() == fn && f.isdir() == 1) {
			//如果文件夹里面还有文件则不能删除
			for (int i = 0; i < FILESYS_BLK_INDEX_NUM; ++i) {
				auto z = f.nodeindexs()[i];
				if (z != 0) {
					std::cerr << "Error:\t cannot delete non-empty dir" << std::endl;
					return false;
				}
			}
			//清除上级目录FCB内的入口
			auto pt = cwdFCB.nodeindexs();
			for (int i = 0; i < FILESYS_BLK_INDEX_NUM; ++i) {
				if (pt[i] == f.index) {
					pt[i] = 0;
					break;
				}
			}
			//清除磁盘内对应文件的FCB
			_clear_blk(f.index);
			f.index = 0;
			//清除对应文件的FCB缓存
			f = FCBp();
			return true;
		}
	}
	std::cerr << "Error:\t no such file" << std::endl;;
	return false;
}

vector<vector<string>> FileSys::ls() {
	vector<vector<string>> ret;
	for (const auto& f : FCB_in_cwd) {
		if (f.index == 0)continue;
		auto s = string(f.file_name());
		//若是文件夹则在名字后面附带一个"/"
		if (f.isdir())s += "/";
		auto ttt = f.updtime();
		ret.emplace_back(vector<string>{s, std::to_string(f.size()), time2string(ttt)});
	}
	return ret;
}

int FileSys::cd(const string& ss) {
	//相对路径（一次进一个文件夹）
	if (ss[0] != '/') {
		//cd ..返回上一级
		if (ss.size() == 2 && ss[0] == '.' && ss[1] == '.' ||
		    ss.size() == 3 && ss[0] == '.' && ss[1] == '.' && ss[2] == '/') {
			if (cwdFCB.index == 0) {
				std::cerr << "Error:\t already in root" << std::endl;
				return false;
			}
			//更新cwd和cwd内含文件的FCB缓存
			_refresh_cwd_FCB_cache(cwdFCB.father());
			//更新cwd路径记录
			--cwd;
			return true;
		}
		//判断文件名合法
		if (is_legal_fn(ss))
		//真正的cd
			return _cd(ss);
		else {
			std::cerr << "Error:\t illegal path" << std::endl;
			return false;
		}
	}
	//todo
	//绝对路径（"/aa/ss/cc/"或"/aa/xx/ss"）
	else {
		//特判'cd /'
		if (ss.size() == 1 && ss == "/") {
			cwd = FilePath();
			cwd += "";
			_refresh_cwd_FCB_cache(0);
			return true;
		}
		//初步检查路径合法后依次进入下一层，即没有连着的"/"
		auto vss = split(ss, '/');
		for (int i = 0; i < ss.size(); ++i) {
			if (vss[i].size() == 0 && !(i == 0 || i == vss.size() - 1)) {
				std::cerr << "Error:\t illegal path" << std::endl;
				return false;
			}
		}
		int z = vss.back().size() == 0 ? 1 : 0;
		for (int i = 1; i < vss.size() - z; ++i) { if (!_cd(vss[i])) { return false; } }
	}
}

int FileSys::create(const string& fn) { return _newfile(fn, false); }

int FileSys::open(const string& fn) {
	int fd = 0;
	if (!is_legal_fn(fn)) {
		std::cerr << "Error:\t illegal file name" << std::endl;
		return false;
	}
	for (auto& f : FCB_in_cwd) {
		//跳过空块
		if (f.index == 0)continue;
		//找到对应FCB！而且不是文件夹
		if (f.file_name() == fn && f.isdir() == 0) {
			//文件还未被打开,若打开则返回那个fd
			for (int i = 1; i < FILESYS_FD_MAX; ++i) {
				auto& ff = open_file_list[i];
				if (ff.index == 0)continue;
				if (ff.index == f.index) {
					std::cerr << "Error:\t file is already open" << std::endl;
					return i;
				}
			}
			for (int i = 1; i < FILESYS_FD_MAX; ++i) {
				auto& ff = open_file_list[i];
				if (ff.index == 0) {
					ff = f;
					return i;
				}
			}
		}
	}
	std::cerr << "Error:\t no such file in cwd" << std::endl;
	return 0;
}

int FileSys::close(int fd) {
	if (!(fd > 0 && fd < FILESYS_FD_MAX && open_file_list[fd].index != 0)) {
		std::cerr << "Error:\t fd error" << std::endl;
		return false;
	}
	open_file_list[fd] = FCBp();
	open_file_list[fd].index = 0;
	return true;
}

vector<byte> FileSys::read(int fd) {
	//fd在范围内且已经打开
	if (!(fd > 0 && fd < FILESYS_FD_MAX && open_file_list[fd].index != 0)) {
		std::cerr << "Error:\t fd error" << std::endl;
		return {};
	}
	auto&           s    = open_file_list[fd];
	int             size = s.size();
	vector<byte>    ret(size, 0);
	vector<index_t> blks;
	int             cnt = 0;
	//一块一块读到vector<byte>里
	for (int i = 0; i < FILESYS_BLK_INDEX_NUM; i++) {
		index_t ind = s.nodeindexs()[i];
		if (ind != 0) {
			for (int i = 0; i < FILESYS_BLK_SIZE_BYTES; ++i) {
				if (cnt < size) {
					ret[cnt] = MFileImg[ind * FILESYS_BLK_SIZE_BYTES + i];
					++cnt;
				}
				else return ret;
			}
		}
	}

	if (cnt < size)std::cerr << "Warning:\t file real size is NOT equal to FCBp" << std::endl;
	return ret;
}

int FileSys::write(int fd, const string& str) {
	//fd在范围内且已经打开
	if (!(fd > 0 && fd < FILESYS_FD_MAX && open_file_list[fd].index != 0)) {
		std::cerr << "Error:\t fd error" << std::endl;
		return {};
	}
	auto& f = open_file_list[fd];
	size_t size = str.size() + 1;
	//超出单文件长度限制
	if (size > FILESYS_FILE_MAXLEN) {
		std::cerr << "Error:\t exceed max file length" << std::endl;
		return false;
	}
	//找到供写入的块
	vector<index_t> blks;
	while (blks.size() < std::ceil((double)size / (double)FILESYS_BLK_SIZE_BYTES)) {
		auto t = _find_1_avail_blk_front();
		//找不够，则返还这些块
		if (t == 0) {
			std::cerr << "Error:\t no enough space for this file" << std::endl;
			for (auto i : blks)_set_blk_unused(i);
			return false;
		}
		blks.push_back(t);
		_set_blk_used(t);
	}
	//FCB记录文件大小
	f.set_size(size);
	//依次把文件内容写入块
	size_t now = 0, end = 0;
	for (int i = 0; i < blks.size(); ++i) {
		end    = std::min(now + FILESYS_BLK_SIZE_BYTES, size);
		auto z = blks[i] * FILESYS_BLK_SIZE_BYTES;
		//memcpy(MFileImg + z, str.data() + now, end - now);
		for (int ii = now; ii < end; ++ii) { MFileImg[z + ii] = str[now + ii]; }
		now               = end;
		f.nodeindexs()[i] = blks[i];
	}
	return true;
}

int FileSys::del(const string& fn) {
	if (!is_legal_fn(fn)) {
		std::cerr << "Error:\t illegal file name" << std::endl;
		return false;
	}
	for (auto& f : FCB_in_cwd) {
		//跳过空块
		if (f.index == 0)continue;
		//找到对应FCB！而且不能是文件夹
		if (f.file_name() == fn && f.isdir() == 0) {
			//文件未open?
			for (auto& ff : open_file_list) {
				if (f.index == ff.index) {
					std::cerr << "Error: cannot delete open file" << std::endl;
					return false;
				}
			}
			//依次清除所有存储文件内容的block
			for (int i = 0; i < FILESYS_BLK_INDEX_NUM; ++i) {
				auto z = f.nodeindexs()[i];
				if (z != 0) {
					_clear_blk(z);
					_set_blk_unused(z);
				}
			}
			//清除上级目录FCB内的入口
			auto pt = cwdFCB.nodeindexs();
			for (int i = 0; i < FILESYS_BLK_INDEX_NUM; ++i) {
				if (pt[i] == f.index) {
					pt[i] = 0;
					break;
				}
			}
			//清除磁盘内对应文件的FCB
			_clear_blk(f.index);
			//清除对应文件的FCB缓存
			f = FCBp();

			return true;
		}
	}
	std::cerr << "Error:\t file not found" << std::endl;
	return false;
}

int FileSys::is_fd_open(int fd) {
	if (!(fd > 0 && fd < FILESYS_FD_MAX)) {
		std::cerr << "Error:\t fd error" << std::endl;
		return false;
	}
	if (open_file_list[fd].index != 0)return true;
	return false;
}

string FileSys::get_cwd_str() { return cwd.get(); }

bool FileSys::_cd(const string& fn) {
	if (!is_legal_fn(fn)) {
		std::cerr << "Error:\t illegal path" << std::endl;
		return false;
	}
	for (const auto& s : FCB_in_cwd) {
		//跳过空条目
		if (s.index == 0)continue;
		//文件名相同且为文件夹
		if (fn == s.file_name() && s.isdir()) {
			//更新cwd
			//更新cwd指向的FCB
			_refresh_cwd_FCB_cache(s.index);
			//更新cwd路径记录
			cwd += fn;
			return true;
		}
	}
	std::cerr << "Error:\t no such path existed" << std::endl;
	return false;
}

bool FileSys::_newfile(const string& fn, bool dir) {
	//判断文件名是否合法
	if (!is_legal_fn(fn)) {
		std::cerr << "Error:\t illegal file name" << std::endl;
		return false;
	}
	int  avalentry = 0, i = 0;
	bool found     = false;
	//先找cwd的FCB的空闲条目
	for (const auto& f : FCB_in_cwd) {
		if (f.index == 0) {
			avalentry = (found) ? avalentry : i; //FCB里找第一个空条目
			found     = true;
			continue;
		}
		if (fn == f.file_name()) {
			std::cerr << "Error:\t a file with same name exists in cwd" << std::endl;
			return false;
		}
		++i;
	}
	//再找空闲磁盘块存放新文件的FCB
	auto avalblk = _find_1_avail_blk_front();
	if (!found) {
		std::cerr << "Error:\t this dir is full" << std::endl;
		return false;
	}
	if (avalblk == 0) {
		std::cerr << "Error:\t no space on this filesystem" << std::endl;
		return false;
	}
	//创建新文件FCB，写入块，更新cwdFCB，并更新cwdFCB包含的条目
	_set_blk_used(avalblk);
	FCB_in_cwd[avalentry]          = FCBp(MFileImg, avalblk, fn.data(), dir, local_time_now(), cwdFCB.index, 0);
	cwdFCB.nodeindexs()[avalentry] = avalblk;
	return true;
}

bool FileSys::_refresh_cwd_FCB_cache(const index_t index) {
	//更新cwd
	cwdFCB = FCBp(MFileImg, index);;
	//更新cwd指向的FCB
	auto p = cwdFCB.nodeindexs();
	for (int i = 0; i < FILESYS_BLK_INDEX_NUM; ++i) {
		if (p[i] == 0) {
			FCB_in_cwd[i]       = FCBp();
			FCB_in_cwd[i].index = 0;
		}
		else
			FCB_in_cwd[i] = FCBp(MFileImg, p[i]);
	}
	return true;
}

//bool FileSys::_is_open(const string& fn) {
//	for (auto& f : open_file_list) { if (f.file_name() == fn) { return true; } }
//	return false;
//}

void FileSys::_clear_blk(const index_t index) {
	memset(MFileImg + index * FILESYS_BLK_SIZE_BYTES, 0, FILESYS_BLK_SIZE_BYTES);
}

bool FileSys::is_legal_fn(const string& fn) {
	if (fn.empty())
		return false;
	for (char c : fn) {
		if (
			!(
				c == 46 ||              // '.'
				(48 <= c && c <= 57) || // 0-9
				(65 <= c && c <= 90) || // A-Z
				(97 <= c && c <= 122)   // a-z
			)
		)
			return false;
	}
	return true;
}

bool FileSys::is_legal_fn_slash(const string& fn) {
	if (fn.empty())
		return false;
	for (char c : fn) {
		if (
			!(
				c == 46 ||              // '.'
				c == 47 ||              // '/'
				(48 <= c && c <= 57) || // 0-9
				(65 <= c && c <= 90) || // A-Z
				(97 <= c && c <= 122)   // a-z
			)
		)
			return false;
	}
	return true;
}

bool FileSys::is_legal_path(const string& p) {
	if (p[0] == '/') { return is_legal_fn_slash(p); }
	else return is_legal_fn(p);
}


inline bool FileSys::_is_blk_used(const index_t index) const {
	return (bitmap[index / 8] & MASK[index % 8]) == MASK[index % 8];
}


inline void FileSys::_set_blk_used(const index_t index) { bitmap[index / 8] |= MASK[index % 8]; }


inline void FileSys::_set_blk_unused(const index_t index) { bitmap[index / 8] &= ~MASK[index % 8]; }


//todo 性能优化
inline index_t FileSys::_find_1_avail_blk_front() {
	for (index_t i = 1; i < FILESYS_BLKS_NUM; ++i)
		if (!_is_blk_used(i))
			return i;
	return 0;
}


//todo 性能优化
inline index_t FileSys::_find_next_1_blk_back() {
	for (index_t i = FILESYS_BLKS_NUM - 1; i > 0; --i)
		if (!_is_blk_used(i))
			return i;
	return 0;
}

inline int FileSys::_find_1_avail_fd() {
	for (int i = 0; i < FILESYS_FD_MAX; ++i) {
		if (open_file_list[i].index == 0)continue;
		return i;
	}
	return 0;
}
}

```



#### main.cpp

```cpp
#include <iostream>

#include "FileSys.h"
#include "utils.h"

using namespace std;
using namespace MF;

int main(int argc, const char** argv) {
	string c, a, b;
	//shared_ptr<MF::FileSys> ffs;
	FileSys* ffs = nullptr;
	//模式，0=加载新建文件系统镜像(new, sfs)，1=文件系统内操作(包含exit)
	int mode = 0;
	//cout << MF::time2string(MF::local_time_now()) << endl;
	while (true) {
		cin >> c;
		if (mode == 0) {
			if (c == "new") {
				cin >> a;
				//ffs = make_shared<FileSys>(FileSys::newfsys());
				ffs  = FileSys::newfsys(a);
				mode = 1;

				//todo
			}
			else if (c == "sfs") {
				cin >> a;
				ffs = FileSys::load(a);
				if (ffs != nullptr)
					mode = 1;
				//todo load
			}
		}
		else if (mode == 1) {
			if (c == "exit") {
				ffs->save();
				mode = 0;
			}
			else if (c == "mkdir") {
				cin >> a;
				if (ffs == nullptr) {
					cerr << "Error:\t no filesystem is open" << endl;
					continue;
				}
				ffs->mkdir(a);
			}
			else if (c == "rmdir") {
				cin >> a;
				if (ffs == nullptr) {
					cerr << "Error:\t no filesystem is open" << endl;
					continue;
				}
				ffs->rmdir(a);
			}
			else if (c == "ls") {
				if (ffs == nullptr) {
					cerr << "Error:\t no filesystem is open" << endl;
					continue;
				}
				auto arr_str_ls = ffs->ls();
				for (auto& str_file : arr_str_ls) {
					for (auto& ele : str_file) { cout << ele << "\t"; }
					cout << endl;
				}
				//cout << endl;
			}
			else if (c == "cd") {
				cin >> a;
				if (ffs == nullptr) {
					cerr << "Error:\t no filesystem is open" << endl;
					continue;
				}
				ffs->cd(a);
			}
			else if (c == "create") {
				cin >> a;
				if (ffs == nullptr) {
					cerr << "Error:\t no filesystem is open" << endl;
					continue;
				}
				ffs->create(a);
			}
			else if (c == "open") {
				if (ffs == nullptr) {
					cerr << "Error:\t no filesystem is open" << endl;
					continue;
				}
				cin >> a;
				cout << "fd: " << ffs->open(a) << endl;
			}
			else if (c == "close") {
				string fdstr;
				cin >> fdstr;
				int fd = -1;
				if (MF::is_number(fdstr)) {
					fd = stoi(fdstr);
					if (ffs == nullptr) {
						cerr << "Error:\t no filesystem is open" << endl;
						continue;
					}
					ffs->close(fd);
				}
				else { cerr << "Error:\t fd must be a integer" << endl; }
			}
			else if (c == "read") {
				string fdstr;
				cin >> fdstr;
				int fd = -1;
				if (MF::is_number(fdstr)) {
					fd = stoi(fdstr);
					if (ffs == nullptr) {
						cerr << "Error:\t no filesystem is open" << endl;
						continue;
					}
					auto ans = ffs->read(fd);
					for (auto& ch : ans) { cout << static_cast<char>(ch); }
					cout << endl;
				}
				else { cerr << "Error:\t fd must be a integer" << endl; }
			}
			else if (c == "write") {
				string fdstr;
				cin >> fdstr;
				int fd = -1;
				if (MF::is_number(fdstr)) {
					fd = stoi(fdstr);
					if (ffs == nullptr) {
						cerr << "Error:\t no filesystem is open" << endl;
						continue;
					}
					if (ffs->is_fd_open(fd)) {
						cout << "Info:\t use CTRL+D (*nix) or CTRL+Z - ENTER (Windows) to end input" << endl;
						string stmp;
						b = "";
						while (std::getline(std::cin, stmp)) { b += stmp; }
						ffs->write(fd, b);
						// 重置cin流的EOF状态
						cin.clear();
					}
				}
				else { cerr << "Error:\t fd must be a integer" << endl; }
			}
			else if (c == "delete") {
				cin >> a;
				if (ffs == nullptr) {
					cerr << "Error:\t no filesystem is open" << endl;
					continue;
				}
				ffs->del(a);
			}
			else;
		}
		if (mode == 1 && ffs != nullptr) {
			//模仿shell刷新一个新行
			cout << endl << ffs->get_cwd_str() << " $ ";
		}
	}
}

```

#### utils.cpp

```cpp
#include "utils.h"
#define _CRT_SECURE_NO_WARNINGS

namespace MF
{
std::vector<std::string> split(const std::string& text, char sep) {
	std::vector<std::string> tokens;
	std::size_t              start = 0, end = 0;
	while ((end = text.find(sep, start)) != std::string::npos) {
		tokens.push_back(text.substr(start, end - start));
		start = end + 1;
	}
	tokens.push_back(text.substr(start));
	return tokens;
}

std::time_t local_time_now() {
	return std::chrono::system_clock::to_time_t(
			std::chrono::system_clock::now());
}

std::string time2string(std::time_t tt) {
	auto              z   = tt;
	auto              zz  = &z;
	auto              zzz = std::localtime(zz);
	std::tm           tm  = *zzz; //Locale time-zone, usually UTC by default.
	std::stringstream ss;
	ss << std::put_time(&tm, "%F %T %z");
	return ss.str();
}

bool is_number(const std::string& s) {
	std::string::const_iterator it = s.begin();
	while (it != s.end() && std::isdigit(*it)) ++it;
	return !s.empty() && it == s.end();
}
}

```





## **IV. 采用的测试方法及错误分析**



### **测试方法**

1. 调试时中断，查看变量的值
2. 运行时打印部分变量与信息
3. 依靠 IDE（ Visual Studio 2022 、ReSharper C++ ）提供的静态分析功能
4. 实际运行，观察运行结果是否与预期相符
5. 加断点，逐步运行调试



### **错误分析**

1. `main` 函数内使用智能指针 `shared_ptr<>` 托管 `FileSys` 对象，导致该对象内部的 `MFileImg` 大数组头地址在变化，导致写入错误位置。更换为普通指针即解决问题。
2. 使用vector动态管理数组，可能是因为发生了内存重分配，导致FCB缓存（ `FCB_in_cwd` ）内的FCB指针变为 `nullptr` ，访问这些空指针会出错。更换为一般的数组即解决问题
3. 某处判断条件错误，导致创建文件时写入的上级目录FCB索引总是第一个索引项。
4. `main` 函数内，如果直接 `cin ` 一个整数，而且输入不是整数的话，会发生阻塞。更换为读入成字符串然后判断是否可以转换为整数后再处理，即解决问题。
   - C++标准库（ C++14 标准）中没有这种判断函数，有一个转换函数（但是如果不能转换会产生异常，而异常在C++里是个很麻烦的事情），因此自行实现。
5. 不能对右值取地址。
6. `vector erase` 时会导致迭代器失效。
7. `0` 有时会隐式类型转换为指针的 `nullptr` 。
8. 



## **V. 本次实验经验及体会**

