# 操作系统  实验 4





> **王雨轩		1120190887		08011901**

[toc]

## **O. 使用说明**

双击可执行文件 `.exe` 运行。运行时有两种状态：一种是未加载镜像的状态，可以进行加载新建文件系统镜像的操作(new, sfs)；另一种是已加载镜像状态，可以进行文件系统内操作(包含exit) 。

随可执行文件附带一个预先准备好的镜像文件 `fs1.mfsimg` ，放置于同一路径下后打开可执行文件，输入命令 `sfs fs1.mfsimg ` 加载该镜像，随后即可随意使用。

具体操作说明请见下文。



### 提供操作与命令格式

类似 *nix 系统惯例，以下命令，除 `exit` 成功时返回保存文件名、 `open` 成功时返回 `fd` 值、 `ls` 成功时返回当前目录下所有文件信息，在成功执行后没有文字反馈，在出错时会提示具体错误。注意，同一路径下文件夹与文件不能重名。

- `new  <filesys_name>`
  - 建立一个新的简单文件系统，需提供名称；
- `sfs  <filesys_name>`
  - 打开一个简单文件系统，需提供名称；
- `exit`
  - 保存并退出打开的简单文件系统，名称不含扩展名( `.mfsimg` ) 时自动添加；
- `mkdir  <dir_name>`
  - 创建子目录，名称不能和当前目录下其它文件重复；
- `rmdir  <dir_name>`
  - 删除子目录，名称必须是当前目录下的 ***非空*** 文件夹，而非文件；
- `ls`
  - 显示当前目录内含的文件；
- `cd  <dir_name>`
  - 更改当前目录，目前只测试过相对路径进入下一级( `cd dir` )和上一级( `cd ..` )和绝对路径进入根目录( `cd /` )；
- `create  <file_name>`
  - 创建文件，名称不能和当前目录下其它文件重复；
- `open  <file_name>`
  - 打开文件，名称必须是当前目录下的文件，返回 `fd` 号；
- `close  <fd:int>`
  - 关闭文件，参数为 `0-127` 的整数，若提供的 `fd` 不对应已打开文件则报错；
- `read  <fd:int>`
  - 读文件，参数为 `0-127` 的整数，若提供的 `fd` 不对应已打开文件则报错；
- `write  <fd:int>`
  - 覆盖写入文件，参数为 `0-127` 的整数，若提供的 `fd` 不对应已打开文件则报错，如果对应，则进入输入状态，用 EOF 结束（手动输入 EOF 的方法为：Windows下按回车再按 Ctrl+Z 再按回车，*nix 下按Crtl+D）；
- `delete  <file_name>`
  - 删除文件，名称必须是当前目录下的文件而非文件夹。



## **I. 数据结构及符号说明**



### **数据结构**



#### FCBp

`FCBp` 是一个类似FCB的结构体，但是并不实际存储FCB的内容。它的

- 数据成员包括
  1. 此FCB所在块的起始地址
  2. 块索引
  3. 指向文件信息的一些指针，实际内容存储在内存中的磁盘镜像的对应块里
- 方法包括
  1. 根据数据成员中的指向文件信息的一些指针，从内存中的磁盘镜像的对应块里得到文件信息
  2. 根据数据成员中的指向文件信息的一些指针，向内存中的磁盘镜像的对应块里写入文件信息

![FCBp.drawio](%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/FCBp.drawio.png)

```cpp
struct FCBp
{
public:
	//默认构造函数
	explicit FCBp() = default;
	explicit FCBp(byte* p);
	//根据块索引、磁盘内存镜像头指针，从索引对应的块建立FCB结构体
	explicit FCBp(byte* p, index_t ind);
	//根据块索引、磁盘内存镜像头指针、需要在磁盘上建立的FCB的信息，在索引对应的块上写入FCB
	explicit FCBp(byte* p, index_t ind, const char fn[], byte isdir, time_t updtime, index_t father, uint32_t size);


	FCBp(const FCBp& f) = default;

	byte*   ptr   = nullptr; // 块起始地址
	index_t index = 0;       // 第几块

	// 数据共 1024 B
	char*     p_file_name  = nullptr; // 113 = FILESYS_FILENAME_MAXLEN*1B
	char*     p_isdir      = nullptr; // 1*1B，为0是普通文件，为1是目录
	time_t*   p_updtime    = nullptr; // 1*8B, 更新时间
	index_t*  p_father     = nullptr; // 1*2B，为文件的父目录，根目录的父目录为0
	uint32_t* p_size       = nullptr; // 1*4B，文件大小（字节）
	index_t*  p_nodeindexs = nullptr; // 896B = FILESYS_BLK_INDEX_NUM*2B
	// 0 代表 空
	// p_isdir == 0 时，
	//		p_nodeindexs 存储文件块索引，一级索引，文件最大244KB
	// p_isdir == 1  时，
	//		p_nodeindexs 存储FCB所在块索引，文件个数最多为224

	//index_t find_1_avail_entrance();

	
	const char* file_name() const;              //从内存中的磁盘镜像读取文件名
	void        set_file_name(const char fn[]); //设置新文件名到内存中的磁盘镜像
	char        isdir() const;                  //从内存中的磁盘镜像读取是否为文件夹
	void        set_isdir(char isdir);          //设置新的是否文件夹到内存中的磁盘镜像
	time_t      updtime() const;                //从内存中的磁盘镜像读取最近修改时间
	void        set_updtime(time_t updtime);    //设置新的修改时间到内存中的磁盘镜像
	index_t     father() const;                 //从内存中的磁盘镜像读取上级目录
	void        set_father(index_t father);     //设置新的上级目录到内存中的磁盘镜像
	uint32_t    size() const;                   //从内存中的磁盘镜像读取文件大小
	void        set_size(uint32_t size);        //设置新文件大小到内存中的磁盘镜像
	index_t*    nodeindexs() const;             //从内存中的磁盘镜像读取FCB内含的索引


};
```



#### FilePath

记录路径，目前只用于记录 `cwd (current working folder)` 当前所在文件夹。

每一级文件夹的 `string` 单独保存，根目录为空字符串。

例如：形如 `"/usr/home/document"`  的路径，其 `FilePath.data` 为 `{"", "usr", "home", "document"}` ； `get()` 方法返回字符串 `/usr/home/document/` 。

```cpp
struct FilePath
{
	vector<string> data;   //每一级文件夹的string单独保存,根目录为空字符串
	string         get();  //得到形如"/dir1/dir2/dir3/"的字符串
	string         last(); //得到最内层的文件夹名

	FilePath& operator+=(const string& fn); // 进入一层
	FilePath& operator--();                 // 退出一层
};
```



#### FileSys

实现文件系统。具体接口与功能说明可见下面代码的注释

```cpp
class FileSys
{
public:
	FileSys(const string& fsn);
	~FileSys();
	//按new时提供的名称保存，智能添加文件扩展名.mfsimg
	bool                   save() { return save(fs_name); } 
	bool                   save(string img_name);
    //根据名称加载镜像，返回一个根据该镜像新创建的FileSys对象指针
	static FileSys*        load(string img_name);      
    //根据名称新建镜像，返回一个根据该镜像新创建的FileSys对象指针
	static FileSys*        newfsys(const string& fsn); 
	int                    mkdir(const string& fn);
	int                    rmdir(const string& fn); //删除文件夹
	vector<vector<string>> ls();
	int                    cd(const string& ss);
	int                    create(const string& fn);
	int                    open(const string& fn);
	int                    close(int fd);
	vector<byte>           read(int fd);
	int                    write(int fd, const string& str); //覆盖写
	int                    del(const string& fn);            //删除文件

	int    is_fd_open(int fd);
	string get_cwd_str(); //方便外部读取cwd

protected:
	bool _cd(const string& fn);                 //相对路径cd
	bool _newfile(const string& fn, bool dir);  //因为mkdir和create很像，所以为了代码复用写了这个函数
	bool _refresh_cwd_FCB_cache(index_t index); //更新cwd中所含文件的FCB缓存

	inline bool    _is_blk_used(index_t index); //利用bitmap判断块是否被占用
	inline void    _set_blk_used(index_t index);//设置bitmap中块被占用
	inline void    _set_blk_unused(index_t index);//设置bitmap中块可用
	inline void    _clear_blk(index_t index);   //清除block内容
	inline index_t _find_1_avail_blk_front();//从前往后开始扫描bitmap，找到一个可用的块，找不到就返回0
	inline index_t _find_next_1_blk_back();  //从后往前开始扫描bitmap，找到一个可用的块，找不到就返回0
	inline int     _find_1_avail_fd();       //寻找一个可用的fd号。返回0即为没有可用的了

	inline static bool is_legal_fn(const string& fn);       //判断文件名是否合法
	inline static bool is_legal_fn_slash(const string& fn); //判断文件名是否合法，合法字符多一个'/'
	inline static bool is_legal_path(const string& p);      //判断路径是否合法


	//FCBp& get_FCB_from_index(const index_t index) const {}

	const unsigned char MASK[8] = {
		0b10000000u, 0b01000000u,
		0b00100000u, 0b00010000u,
		0b00001000u, 0b00000100u,
		0b00000010u, 0b00000001u
	}; //bitmap相关掩码

	unsigned char bitmap[FILESYS_BLKS_NUM / 8]{};   //存放bitmap的数组
	byte          MFileImg[FILESYS_CAPACITY_BYTES]{}; //内存中的磁盘镜像
	FilePath      cwd;                              //当前所在文件夹路径
	FCBp          cwdFCB;                           //当前所在文件夹的FCB
	FCBp          FCB_in_cwd[FILESYS_BLK_INDEX_NUM];//当前所在文件夹内文件的FCB缓存
	vector<FCBp>  open_file_list; //已打开文件的FCB, 0号默认是根目录
	string        fs_name;        //当前文件系统的名字，用于保存和读取文件系统镜像
};
```





### **符号**



#### **FileSys.h**

所有内容均在 `namespace MF` 内



##### *全局常量*

```cpp
constexpr size_t FILESYS_BLK_INDEX_NUM  = 448;     // 每个FCB可容纳多少个索引项目
constexpr size_t FILESYS_BLK_SIZE_BYTES = 1 << 10; // 块大小，1 KB
constexpr size_t FILESYS_BLKS_NUM       = 1 << 12; // 块总数，4096 blocks
constexpr size_t FILESYS_CAPACITY_BYTES = FILESYS_BLK_SIZE_BYTES
					* FILESYS_BLKS_NUM; // 文件系统大小，4 MB, 不含bitmap的512B
constexpr size_t FILESYS_FILENAME_MAXLEN = 113;    // 文件名最大长度，including '\0'
constexpr size_t FILESYS_FILE_MAXLEN     = FILESYS_BLK_INDEX_NUM 
    				* FILESYS_BLK_SIZE_BYTES; // 文件最大大小，448 KB
constexpr size_t FILESYS_FD_MAX          = 128; //最多同时打开128个文件
```



##### *类型别名*

```cpp
using byte = unsigned char; // 用于表示磁盘最小表示单元，byte
using index_t = uint16_t;   // 用于表示索引项。因为块总数为4096，所以2字节长的无符号整数 0-65535 足够使用。
```



##### *`struct FCBp`*

详细请见 上文 [数据结构说明处代码内的注释](#FCBp)

##### *`struct FilePath`*

详细请见 上文 [数据结构说明处代码内的注释](#FilePath)

##### *`class FileSys`*

详细请见 上文 [数据结构说明处代码内的注释](#FileSys)



#### utils.h

该头文件声明了一些与文件系统没有直接关系的实用函数。所有内容均在 `namespace MF` 内。

```cpp
std::vector<std::string> split(const std::string& text, char sep); //实现字符串分割，string.split()
std::time_t              local_time_now();                         //得到当前时间
std::string              time2string(std::time_t tt);              //把时间转为字符串
bool                     is_number(const std::string& s);          //判断一个字符串是否是整数

```

#### main.cpp

主函数在该文件中。主函数内解析输入并转化为相应命令，按需新建 `FileSys` 对象，调用 `FileSys` 实例的相关方法，并把结果输出。

```cpp
string c, a, b;//c是每行第一个输入参数，即命令名；a和b是第二、三个输入参数，按需读取。

FileSys* ffs = nullptr;//指向文件系统对象的指针。按需新建对象。

int mode = 0;//模式，0=加载新建文件系统镜像(new, sfs)，1=文件系统内操作(包含exit)
```

#### test.cpp

测试一些代码片段是否符合预期时使用。现在为空，没有实际内容。



## **II. 算法流程与设计说明**



### **整体设计**

本项目使用语言标准为 `C++14` 与 `C11` ，编译器为 `msvc v143` ，工程文件对应 IDE 为 Visual Studio 2022 。



- 文件结构为：索引结构，**索引表**存放在文件的 `FCB` 里；
  - 有两类文件，一类为普通文件，一类为目录文件；
  - 普通文件FCB索引项记录文件体所在块号，0 代表空记录
  - 目录文件FCB索引项记录该目录下所有文件的FCB所在块号，0 代表空记录
  - 一个 `FCB` 中可容纳 448 个索引
  - 0 号块存放根目录的FCB
- 文件的目录结构为：多级目录——树形目录结构；做很简单的修改后可以实现无环图目录结构。
- 文件分为：文件体（分块存储），FCB（占用 1 块）
  - 基本文件名（含扩展名）最大长度为 `112` ，不含字符串结束的 `'\0'` ；
  - 合法文件名只能由 **大小写字母、数字和英文句点`'.'`** 组成，**除根目录外文件名不能为空**
- 空间布局与管理方法为：位示图 `bitmap`
  - 磁盘镜像大小为 `4 MB` ，分为 `4096` 块，块大小为 `1 KB` 
  - `bitmap ` 大小为`512B`
  - 文件系统空间最小分配单位为 1 块

### **处理流程**

```cpp
bool                   save() { return save(fs_name); }
bool                   save(string img_name);
```

按new时提供的名称保存，智能添加文件扩展名 `.mfsimg` 。



```cpp
//按new时提供的名称保存，智能添加文件扩展名.mfsimg
bool                   save() { return save(fs_name); } 
bool                   save(string img_name);
//根据名称加载镜像，返回一个根据该镜像新创建的FileSys对象指针
static FileSys*        load(string img_name);      
//根据名称新建镜像，返回一个根据该镜像新创建的FileSys对象指针
static FileSys*        newfsys(const string& fsn); 
int                    mkdir(const string& fn);
int                    rmdir(const string& fn); //删除文件夹
vector<vector<string>> ls();
int                    cd(const string& ss);
int                    create(const string& fn);
int                    open(const string& fn);
int                    close(int fd);
vector<byte>           read(int fd);
int                    write(int fd, const string& str); //覆盖写
int                    del(const string& fn);            //删除文件

int    is_fd_open(int fd);
string get_cwd_str(); //方便外部读取cwd


bool _cd(const string& fn);                 //相对路径cd
bool _newfile(const string& fn, bool dir);  //因为mkdir和create很像，所以为了代码复用写了这个函数
bool _refresh_cwd_FCB_cache(index_t index); //更新cwd中所含文件的FCB缓存
	//bool _is_open(const string& fn);            //判断文件是否在已打开文件列表里

inline bool    _is_blk_used(index_t index) const; //利用bitmap判断块是否被占用
inline void    _set_blk_used(index_t index);      //设置bitmap中块被占用
inline void    _set_blk_unused(index_t index);    //设置bitmap中块可用
inline void    _clear_blk(index_t index);         //清除block内容
inline index_t _find_1_avail_blk_front();         //从前往后开始扫描bitmap，找到一个可用的块，找不到就返回0
inline index_t _find_next_1_blk_back();           //从后往前开始扫描bitmap，找到一个可用的块，找不到就返回0
inline int     _find_1_avail_fd();                //寻找一个可用的fd号。返回0即为没有可用的了

inline static bool is_legal_fn(const string& fn);       //判断文件名是否合法
inline static bool is_legal_fn_slash(const string& fn); //判断文件名是否合法，合法字符多一个'/'
inline static bool is_legal_path(const string& p);      //判断路径是否合法
```





### **重要模块的详细设计、功能和接口说明**

关于 `FCBp` 、`FilePath` 、 `FileSys` ，请见 上文 [数据结构说明处正文及代码内的注释](#FCBp)

关于 `utils.h` 内的实用函数，请见 上文 [utils.h](#utils.h)





## **III. 源程序（附注释）**

```cpp

```



## **IV. 采用的测试方法，测试结果分析，及错误分析**



### **测试方法**



### **测试结果分析**



### **错误分析**



## **V. 本次实验经验及体会**

